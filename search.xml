<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>南肯辛顿和白城</title>
    <url>/article/london/</url>
    <content><![CDATA[<p>在伦敦的（不到）一年，是即充满了疏离感又觉得亲近的一年。</p>
<a id="more"></a>

<p>从前在香港读书，虽说最后也没扎根下来，陆港的矛盾也原地踏步，最后总还是觉得香港的面目是亲近的，港大不是一所有幸福感的学校，但从那学到的知识却是半点不掺水的。我想，无论多少年以后，再想起夏日西环码头晚上的海风，德辅道创业中心上面的嬉笑，黄克敬311机房日夜敞开的怀抱，我都会抑制不住立刻买张机票飞向赤臘角HKG的冲动。</p>
<p>除此之外还有一段在华盛顿哥伦比亚特区的留学经历，不是很长，从一月岛五月短短的一学期，但我其实在伦敦实际上也就从九月待到三月，还要刨除春节回了一趟家。差不多的时长，华盛顿留给我的是无限冰冷的触感，伦敦却是五味杂陈的。</p>
<p>华盛顿的天，在spring学期是很糟糕的。那年又正好遇到大暴风雪席卷西北部，刚去被冻个半死，没想到越来越冷，只能在图书馆和宿舍（只一条马路之隔），两点一线了好几个月。DC居民是那种类似于纽约的、东北部城市精英特有的敬而远之的态度，彬彬有礼，但到此为止。只去一个学期，买辆车又不划算，地铁又贵，买菜都不方便，更不用说来趟说走就走的旅行。课业上任务也不重，但除了窝在开着暖气的宿舍里，也没什么好做的了。作为运动，经常从宿舍所在的F街，步行到Nation Park的边界A街，再走回来，路上会经过联邦的各色政府衙门，美联储，外交官喜欢去的酒店。</p>
<p>三月下旬是华盛顿的樱花季，满城开满绚烂的樱花后，天气会暖和很多。从来没有在四季分明的城市生活过，华盛顿是第一个。以前从来没有感受到鲜花跟春天的联系是这么紧密，直到在华盛顿，一出门，满眼的姹紫嫣红映入眼帘，会不由自主地被蓬勃的春意感染，蜷缩了一冬的筋骨，抑制不住想跑跑跳跳的欲望。我想，花朵作为植物的交配工具，在这点上，动物、植物、人都是受天性影响，被春天的荷尔蒙支配。</p>
<p>五月，结束了考试之后，坐上了去加州的飞机，在加州游玩一周后，乘坐洛杉矶的航班回国。访问了室友L在交换的加州大学圣地亚哥分校，那是美国很典型的“乡村大学”，美国99%的大学应该都是这样的：在一个小城市、小城镇，绿树环绕之间松松散散地坐落着建筑。其实挺遗憾的，也许最终终其一生，我都未体验过这样的学习环境，以前一直在大城市里的弹丸之地学校学习。想必在“大农村”学习，是截然不同的感受吧。</p>
<p>在加州游玩的一周是很愉快的，跟加州交换的港大同学开了一辆商务车，满满一车人去优山美地玩耍。我自己探索了洛杉矶这座巨型都市。很久以后看爱乐之城、洛城机密和昆汀的低俗小说，都能共鸣到强烈的那种说不清道不明的洛杉矶气息。上海被称为魔都，洛杉矶也是有几分这种“魔”味的。“魔都”，总是巨大的、多彩的，陌生人保持疏离，没人无聊到会在意别人的过去，任何人都能在“魔都”里找到自己中意那个“魔法”。魔都的居民是自私的，但包容也从自私中来。</p>
<p>离开了美国，没有强烈的留念，没有想留在那里的愿望。美国是个好地方，有钱、没钱，都有方法过得很潇洒，但享受美国的快乐并不需要住在当地，仅仅是留恋美国的地大物博，资源丰富到奢侈的优点的话，把他当个旅游景点就行。真正有移民美国需求的人，其实只有三种：一种是在国内经济极其拮据，只能出卖苦力的人，一种是对美国的立国价值观有无限认同感，从而多国内体制忍无可忍的人，再有就是需要转移灰色财富的人了。除此之外的人，从中国迁移到美国其实获取不到多少价值。</p>
<hr>
<p>除了英美，另一个给我留下了很深的国家，是日本。我去过两次日本，一次是初三毕业跟我母亲学校的老师一起去的本州，一次是和同学冬天去的北海道。相比美国来说，日本的机会其实稀缺得多，移民政策也紧得多。所以结果是对日本的物质条件和软实力倾羡的同学不少，但能移民的屈指可数。就我而言，我很喜欢日本城市、小镇始终如一的干净整洁。既是幸运也是不行，日本京都、奈良对古中国文明保留地那么出色，惋惜我国文物保护工作的极度匮乏。或许百年以后，奈良还是那个奈良，而中国却找不到这样一个酷似长安的地方了。</p>
<p>日本对于中国的意义，很大程度上是提供了东亚的一个发达国家样本。香港和新加坡都是城邦，韩国依托美国的直接援助，没有借鉴意义。日本是唯一一个东方文明辐射范围下的发达国家，中国总有一天，也许是不久的将来，总要成为发达国家，那日本的现状，日本现在的优势和瓶颈，都是我们未来极有可能面对的</p>
<hr>
<p>说回到英国，伦敦</p>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>London</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac程序环境初始设置指南</title>
    <url>/article/mac-setup/</url>
    <content><![CDATA[<p>更新于2020年6月。</p>
<a id="more"></a>

<h2 id="Python-Environment"><a href="#Python-Environment" class="headerlink" title="Python Environment"></a>Python Environment</h2><ul>
<li>Anaconda distrbution<ul>
<li>在Catalina的某一个版本后Dock里的Navigator就打不开了，因为Apple修改了第三方应用的权限，现在Anaconda无法放在用户根目录下的<code>~/Anaconda</code>，而只能在<code>~/opt</code>下，所以Dock里的快捷方式的目标失效了。不影响终端里调用任何Anaconda的功能，如何解决Dock图标的问题请谷歌</li>
</ul>
</li>
<li>Tensforflow，通过pip安装，需要打开小火箭的Global mode</li>
</ul>
<h2 id="macOS-特色-IDE-编辑器"><a href="#macOS-特色-IDE-编辑器" class="headerlink" title="macOS 特色, IDE, 编辑器"></a>macOS 特色, IDE, 编辑器</h2><ul>
<li>Homebrew</li>
<li>JetBrains Pycharm</li>
</ul>
<h2 id="其他语言和工具"><a href="#其他语言和工具" class="headerlink" title="其他语言和工具"></a>其他语言和工具</h2><ul>
<li>Node.js (以及打包的npm)</li>
<li>博客：Hexo和Next</li>
<li>Vscode</li>
<li>Xcode：很多包，比如brew需要Xcode的command line tool，或者是需要完整的Xcode应用程序</li>
<li>🍅：ShadowsocksX-NG-R8</li>
<li>Oh-my-zsh：<code>zsh</code>已经预装在新的macOS上，而且是默认终端解释器</li>
<li>终端美化: iTerm<ul>
<li>推荐Pure的终端主题方案<ul>
<li>需要在Oh-my-zsh里将默认主题更改为空，使Pure生效。<code>ZSH_THEME=&quot;&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li>选装：Matlab，R</li>
<li>选装：JetBrains Mono等线字体，替换终端的Monaco字体</li>
</ul>
<h2 id="办公"><a href="#办公" class="headerlink" title="办公"></a>办公</h2><ul>
<li>高等院校提供的正版Office 365套装，包括Word，Excel和Outlook</li>
<li>Chrome</li>
<li>Typora：超好用的Markdown编辑器，比Word轻度文字工作</li>
<li>选装：Latex (macTex distribution)<ul>
<li>以及适配的WYSIWYM (What you see is what you mean) 编辑器 Lyx，编辑公式较多的Latex文章非常好用</li>
</ul>
</li>
</ul>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul>
<li>欧陆词典mac版，可以快捷键打开查词小窗口，一秒钟查到想要的词然后迅速切回原来的工作</li>
</ul>
<h2 id="通讯和娱乐"><a href="#通讯和娱乐" class="headerlink" title="通讯和娱乐"></a>通讯和娱乐</h2><ul>
<li>QQ</li>
<li>QQ音乐</li>
<li>微信mac版</li>
<li>Telegram for macOS<ul>
<li>需要配合🍅使用</li>
<li>ssr下直接打开tg是登陆不了的，输入手机号后会timeout。解决方法是手动配置tg的proxy。模式选择socks5，地址127.0.0.1，端口在小火箭的advance preference里确认，一般默认1086端口。设置proxy后重启tg，一定要重启！然后应该可以正常输入手机号码和验证码后登陆</li>
</ul>
</li>
</ul>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p><code>~/.zshrc</code>里设置终端的端口使用ssr的端口。具体端口查看小火箭的设置，一般是1086。</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssr termimal proxy</span></span><br><span class="line"><span class="built_in">alias</span> proxy=<span class="string">'export all_proxy=socks5://127.0.0.1:1080'</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">'unset all_proxy'</span></span><br><span class="line"><span class="built_in">alias</span> ip=<span class="string">'curl cip.cc'</span></span><br></pre></td></tr></table></figure>

<p>获得🍅能力之后，建议下载如Tensorflow之类的包的时候打开全局模式，解决源的速度慢的问题。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>pip的配置</title>
    <url>/python-pip/</url>
    <content><![CDATA[<p>我们在<a href="/gitlab-ci/" title="Gitlab CI 使用笔记">Gitlab CI 使用笔记</a>中提到Gitlab可以在任何一个repo设置一个repo私有的PyPI。<br>那么，我们把使用git tag比如<code>release/1.0.0</code>这样的标签，推送到服务器触发CI，自动发布到PyPI上之后，<br>如何在任何一台有访问这个PyPI权限的电脑上安装package呢。</p>
<p>首先，PyPI是包含在Package Registry里面的，而Package Registry是Gitlab API的一部分，想要访问<br>PyPI，就必须先通过API的验证。Gitlab API的验证方式主要有三种</p>
<ul>
<li>Private token，即你可以在Settings&gt;Token里手动申请一个token，然后记住，来证明你的身份</li>
<li>CI job token，这个token在CI的容器环境内自动定义为一个环境变量，<code>$CI_JOB_TOKEN</code></li>
<li>Deploy token，暂时不展开</li>
</ul>
<p>一般创建一个单独的repo，用这个repo的Package Registry来存储全部项目的安装包</p>
<p>假设我们成功编译、测试、上传、发布了一个Python包到这个公共库的PyPI里面，打开PyPI的页面后，后看到</p>
<p>Installation<br>Pip Command</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install hello-world --extra-index-url https:&#x2F;&#x2F;__token__:&lt;your_personal_token&gt;@gitlab.example.com&#x2F;api&#x2F;v4&#x2F;projects&#x2F;:id&#x2F;packages&#x2F;pypi&#x2F;simple</span><br></pre></td></tr></table></figure>
<p>这个<code>your_personal_token</code>意味你必须要有权限才能从PyPI <code>pip install hello-world</code>。</p>
<p>固然我们可以每次<code>pip install</code>都提供这串URL，但还是比较不方便，如何让<code>pip</code>在每次安装的时候不仅检索官方的index，也检索我们的私有PyPI呢？</p>
<p><code>pip</code>提供了一<a href="https://pip.pypa.io/en/stable/user_guide/#config-file" target="_blank" rel="noopener">个配置文件</a>，这个文件在Windows里是用户目录文件下的<code>%APPDATA%\pip\pip.ini</code>，<br>如果没有这个文件就手动创建；在Unix是<code>~/.config/pip/pip.conf</code>，内容和格式是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">proxy &#x3D; http:&#x2F;&#x2F;127.0.0.1:8080</span><br><span class="line">trusted-host &#x3D;  pypi.python.org</span><br><span class="line">                pypi.org</span><br><span class="line">                gitlab.example.com</span><br><span class="line"></span><br><span class="line">extra_index_url &#x3D; https:&#x2F;&#x2F;__token__:&lt;your_personal_token&gt;@gitlab.example.com&#x2F;api&#x2F;v4&#x2F;projects&#x2F;:id&#x2F;packages&#x2F;pypi&#x2F;simple</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pip install</code>命令的很多参数，都可以在这个文件中配置，比如<code>extra_index_url</code>对应的就是<code>pip install --extra-index-url</code>。</li>
<li><code>proxy</code>让<code>pip</code>走代理</li>
<li>如果你的PyPI server用的是私有证书，而且客户机没有信任该证书，<code>trusted-host</code>可以让<code>pip</code>不验证服务器的身份</li>
<li>设置<code>extra_index_url</code>后所有的<code>pip install</code>都会额外检索这个PyPI</li>
</ul>
<blockquote>
<p>私有PyPI里的包建议和官方PyPI的包分开命名，比如package叫做<code>hello-world</code>，发布在PyPI的名称可以叫<code>my-site-hello-world</code>，<br>否则如果你的package和官方PyPI的package名字重合的话，你的<code>pip install</code>会优先安装官方的package</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>魔都六七月</title>
    <url>/article/shanghai-july/</url>
    <content><![CDATA[<p>在上海定居一月有余了。</p>
<a id="more"></a>

<p>以上海人的标准来看，我是个如假包换的外地人。之前从来没来过上海，甚至连路过转机都没有，北上广深，超一线城市，另外三个去的次数都不少了，唯独这有魔都之称的上海，在过去从未涉猎。至于原因么，我也说不上来，自从高考填志愿时在复旦和上交之间摇摆，却意外地通过了港大的面试，阴差阳错地成了留学生，之后便是一点去上海的理由都没有。</p>
<p>在这之前。我其实不讨厌上海，甚至可以说有点喜欢。上大学的时候我坚定地把北京划掉了，觉得终究是个南方人适应不了北京的气候。那剩下的就只有上海的。也许旅游从来没把上海当作目的地，就是为了将来的现在，把家安在上海，从此长长久久地住到了这里。</p>
<p>6月6日，从深圳坐东航的航班到浦东机场。这是今年第二次来浦东机场，上一次从英国跑毒回香港，上海浦东转机回深圳，坐机场的隔离大巴从T3转移到T2，路上看着空旷的浦东，还未想过自己真的会定居上海。</p>
<p>在虹桥区租了房，在浦东上班，每天坐八号线转九号线。公司在一个有着很诗意名字的地铁站，叫芳甸路。芳草碧连天。来上海前最担心的是上班地铁会很挤，以前在车公庙实习的时候，一号线上挤得前胸贴后背。上海二号线会特别多人，八号线九号线都还好，浦东过了陆家嘴后，车厢竟空空荡荡的。</p>
<p>房子租在虹口的一片老城区，两室一厅，月租不到六千。说是老城区，其实并不破旧，只是房子年纪比较大，是那种不到十层的无电梯的扁平小区。住在一楼，不用担心爬楼梯，家门口走一百米就有个菜市场和罗森。上海的便利店非常多，711、全家和罗森，这跟深圳很不一样。屋子背街的那一边有个围起来的小院子，之前的租客没收拾，长满了杂草，想着空闲下来了把院子整备一下。</p>
<p>租房的时候没怎么注意，有天路过一个房产中介，发现家附近的房子个个强调是学区房。打开地图一看，呵！同济就在下个路口，同济、复旦和上财三个校区一字排开。</p>
<p>六月刚来的时候，天气非常湿，衣服好几日也晾不干，赶紧下单了一台抽湿机，放在家里呼呼作响。还没入职的时候每日无所事事，每天有收不完的快递，也没办法出去游览一下。买了台索尼的4K电视，在亚马逊海外购订了个Xbox One X，从英国大老远寄过来，打打巫师和荒野大镖客一天过得很快。哦，宜家订家具的时候顺便买了套宜家的电钻套装，桌子凳子柜子躺椅自己摸索着装好了。其实耐心点看说明书，都不是很难。</p>
<p>快要上班了，终于觉得至少要游客打个卡吧。去了外滩，看了东方明珠电视塔。在浦西看东方明珠，觉得普普通通，没想到后来在国金中心从底下看的时候，东方明珠是那么巨大一个。坐476路公交车回家，车上的上海话报站广播是那么有趣，每到一站忍不住要模仿一遍。交完最后一个考试，找了个酒吧喝一杯，没一会有人大打出手，从店里达到店外，酒吧的伙计都劝不住。</p>
<p>上海有一个全国独一无二的东西：垃圾分类。干垃圾，湿垃圾，有害垃圾，可回收垃圾。厨房里放三个垃圾桶，习惯了会觉得不算麻烦，顺手就搞了。</p>
<p>以前在深圳，觉得深圳是新贵城市，new money。来了上海，发现深圳是个土鳖。从来只有old money和no money。原先受电影电视影响，以为上海人是假洋气，好面子，有一天下班在公司楼下看到一家人牵着头羊驼在溜，佩服地不行，这哪里是小资情调，这是妥妥的old money啊。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>上海</tag>
      </tags>
  </entry>
  <entry>
    <title>Win/Linux虚拟环境使用笔记</title>
    <url>/article/work-notebook/</url>
    <content><![CDATA[<p>在公司搬砖用的环境是一台win台式机，i7+A卡，配上双屏，一屏竖着看代码一屏横着看网页，全都公司报销了。自己配了个Niz的82键配列静电容键盘，35g压力，打起来像戳棉花糖一样。</p>
<a id="more"></a>


<h2 id="怎么番茄"><a href="#怎么番茄" class="headerlink" title="怎么番茄"></a>怎么番茄</h2><p>现在用的机场服务是<a href="https://ntt-co-jp.club" target="_blank" rel="noopener">CNIX</a></p>
<p>订阅软件，Windows首推Clash for Win; macOS平台首推clash X。</p>
<h3 id="Git代理"><a href="#Git代理" class="headerlink" title="Git代理"></a>Git代理</h3><p>代理是SS/SSR的话可以用socks5，下面两种方法本质上一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 鼠标停留在状态栏的小火箭上会显示端口</span><br><span class="line">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:7890&#39;</span><br><span class="line">git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:7890&#39;</span><br></pre></td></tr></table></figure>

<p>也可以直接编辑文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.gitconfig</span><br><span class="line"># [http]</span><br><span class="line">#     proxy &#x3D; http:&#x2F;&#x2F;&lt;主机ip&gt;:&lt;7890&gt;</span><br></pre></td></tr></table></figure>

<h3 id="npm淘宝源"><a href="#npm淘宝源" class="headerlink" title="npm淘宝源"></a><code>npm</code>淘宝源</h3><p><code>npm install</code>在ssr设置了全局代理的情况下还是会下载卡死，<code>npm config</code>配置代理实测并不能解决问题。可以配置淘宝源结局，如果已经设置了代理要<code>npm config edit</code>把代理相关的行删掉，再</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>


<h2 id="Linux虚拟机"><a href="#Linux虚拟机" class="headerlink" title="Linux虚拟机"></a>Linux虚拟机</h2><p>以前用过VirtualBox和Mac的Parallel Desktop，总体来说Parallel Desktop的体验要好一些，毕竟收费，但还是存在一些比较烦人的bug。这次尝新了VMware Workstation。VMware也是付费程序，但由于不重视保护版权，激活码在网上很多，商用的话还是要支持正版。</p>
<p>用VMware在Windows下安装Ubuntu的<a href="https://zhuanlan.zhihu.com/p/41940739" target="_blank" rel="noopener">手把手教程</a>。</p>
<h3 id="配置虚拟机的代理"><a href="#配置虚拟机的代理" class="headerlink" title="配置虚拟机的代理"></a>配置虚拟机的代理</h3><ul>
<li>假设主机上番茄软件用的是<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases" target="_blank" rel="noopener">Clash for win</a>，General &gt; 勾选Allow LAN（允许局域网的连接），记录下Port端口（默认7890）</li>
<li>切换到Ubuntu，Settings&gt;Network，Network Proxy设置为Manual</li>
<li>四个选项都设置为<code>&lt;主机ip&gt;:7890</code></li>
</ul>
<p>VMware的网络模式最好是桥接模式，不推荐用NAT模式，虚拟机上的web服务会没办法广播到全局域网，给同事demo东西会不方便。桥接模式下，虚拟机和主机是并列关系，有自己的独立ip。但估计是权限的原因虚拟机虽然可以上网但是不能独立配置代理，只能通过主机的LAN连接走主机的代理。</p>
<h3 id="配置apt-get使用代理"><a href="#配置apt-get使用代理" class="headerlink" title="配置apt-get使用代理"></a>配置<code>apt-get</code>使用代理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/apt.conf</span><br></pre></td></tr></table></figure>

<p>内容为<code>Acquire::http::proxy &quot;http://&lt;主机ip&gt;:7890&quot;</code></p>
<h2 id="在Win和Linux之间共享文件"><a href="#在Win和Linux之间共享文件" class="headerlink" title="在Win和Linux之间共享文件"></a>在Win和Linux之间共享文件</h2><p>出于安全考虑，VMware默认是打开文件共享，关机后在虚拟机设置菜单打开，选择主机上需要共享的目录。这里有个bug，重启虚拟机会导致虚拟机丢失共享的路径，需要再次手动锚定。</p>
<p>把这一段放在你的<code>.bashrc</code>或者<code>.zshrc</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> mount=<span class="string">'/usr/bin/vmhgfs-fuse .host:/ /home/yangrq/share -o subtype=vmhgfs-fuse,allow_other'</span></span><br></pre></td></tr></table></figure>

<p>每次重启在shell里运行<code>mount</code>。</p>
<p>##远程办公<br>公司配了蒲公英的内网穿透服务，其实就是个各个大学都有的校园网vpn服务。下载蒲公英的客户端（全平台都有，包括ios），挂上代理，可以访问内网上的共享文件，web服务，或者远程桌面。远程桌面的软件可以用微软自己的Remote Desktop，或者蒲公英的产品向日葵。</p>
<p>对于数据库架设在局域网内的环境，有这个内网穿透在家可以持续开发调试，还是很方便的。</p>
<h2 id="Oracle数据库"><a href="#Oracle数据库" class="headerlink" title="Oracle数据库"></a>Oracle数据库</h2><p>因为现在写的东西可视化用的是eCharts（Python封装调用）+ Flask的组合，prototype当然要用一个开发足够快的数据库，选了non-SQL的数据库mongoDB，第一次使用非关系数据库，不过很好上手，eCharts本体又是个JS写的库（百度程序员很猛），这一套前后端交互用起来省不少心。</p>
<p>等IT把Oracle数据库弄好，转债和股票的数据就上生产环境了。以前在工行实习的时候，学了python怎么开发Oracle数据库。Oracle那套东西体型太臃肿，80%的东西都是BAT这种体量的公司才用得上的。感谢我坑的DBM课，SQL还是会写一点的😤。</p>
<ol>
<li>图形化工具</li>
</ol>
<p>我推荐DBeaver，这是一个universal database manager，社区版本是免费的，可以连接所有支持jdbc接口的数据库。除了需要知道数据库的host, schema (username), password, service之外，还需要一个跟数据库版本对应的ojdbc包，我们公司的数据库是Oracle 11g，要用ojdbc6.jar，用更高级的会兼容不了。</p>
<ol start="2">
<li>python driver</li>
</ol>
<p><code>cx_Oracle</code>是Oracle的python封装借口，除了<code>pip install cx_Oracle</code>外呢，你还要在电脑上安装Oracle Instant Client（除非你的数据库是在自己电脑上），商用数据库就是这么事儿妈。不同系统的安装方法有所不同，参考<a href="https://www.oracle.com/database/technologies/instant-client/macos-intel-x86-downloads.html" target="_blank" rel="noopener">Oracle</a>。下载之后要让python能找到这个客户端，对于泛UNIX系统来说，在系统<code>$PATH</code>上建立软symlink是最方便的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s ~/instantclient_19_3/libclntsh.dylib /usr/<span class="built_in">local</span>/lib</span><br><span class="line">ln -s ~/instantclient_19_3/libclntsh.dylib.12.1 /usr/<span class="built_in">local</span>/lib</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Gitlab CI 使用笔记</title>
    <url>/gitlab-ci/</url>
    <content><![CDATA[<h2 id="Gitlab-CI-使用笔记"><a href="#Gitlab-CI-使用笔记" class="headerlink" title="Gitlab CI 使用笔记"></a>Gitlab CI 使用笔记</h2><h3 id="Gitlab-CI是如何帮助我们的项目的"><a href="#Gitlab-CI是如何帮助我们的项目的" class="headerlink" title="Gitlab CI是如何帮助我们的项目的"></a>Gitlab CI是如何帮助我们的项目的</h3><p>Python开发的项目，除了享受Python简介的语法和丰富的第三方库之外，会遇到几个痛点</p>
<ul>
<li>动态类型带来的问题<ul>
<li>维护难度大</li>
<li>没有编译环节，错误只能在运行时发现</li>
</ul>
</li>
<li>第三方库，甚至包括Python本身的迭代速度快，不兼容更新是家常便饭，由此导致库的依赖较难管理</li>
</ul>
<p>解决第一个痛点，常见的作法是</p>
<ul>
<li>使用3.7首次引入的<code>typing</code>模块，手动给代码加上类型，这其实跟TypeScript很像，而TypeScript的成功<br>证明<code>typing</code>未来一定是Python不可或缺的一部分，类型标记带来的便利肯定会让Python在大型项目中的实用性<br>得到很大的提升</li>
<li>单元测试覆盖，让bug在测试这个环节尽可能的显现出来</li>
</ul>
<p>解决第二个痛点，有常见的这些方案</p>
<ul>
<li>众所周知，Python库的相互依赖已经到了一个可以说是一团糟的地步，<code>pip</code>在早先版本中，几乎没有处理库的<br>依赖关系的功能，这也是不建议你在复杂的环境中使用<code>pip install</code>的原因，如果你的项目里引用了20个库，其中<br>包括了Panda或者Numpy这样庞大的库，那你的下一个<code>pip install XXX</code>是有很大可能break掉你的代码的。<code>pip</code>在</li>
</ul>
<p>20.X版本后加入了新的Dependency resolve模块，可能会让这样的烦恼少一些。但我们现在就可以使用<code>Pipenv</code>代替<br><code>pip</code>，管理我们的项目依赖，一个<code>Pipfile</code>的作用，参见JavaScript里的<code>packages.json</code>。</p>
<ul>
<li>Conda也是一个较成熟的Python环境管理工具，Anaconda Python分发版已经是很多人的Python首选了，使用<code>conda install</code><br>会让Anaconda的官方repository来帮你解析依赖关系</li>
</ul>
<h3 id="使用持续集成CI完成编译-测试-发布流程"><a href="#使用持续集成CI完成编译-测试-发布流程" class="headerlink" title="使用持续集成CI完成编译-测试-发布流程"></a>使用持续集成CI完成编译-测试-发布流程</h3><p>我司有一个假设在内网里的私有代码仓库，使用的是Gitlab，用Nginx做反向代理后，可以在内网里通过<br><a href="https://gitlab.xuanlingasset.com访问。" target="_blank" rel="noopener">https://gitlab.xuanlingasset.com访问。</a></p>
<p>Gitlab中的每个项目都有一个CI/CD区域，这个区域的功能是定义一些你想要经常运行的编译/测试/发布…的（无聊）工作，让<br>Gitlab来帮你执行，比如你经常有这样一个需求:</p>
<p>经过一天的代码修改，你提交了一个commit，把commit push到Gitlab服务器上，这时你想要运行所有的单元测试，确保你新更改的<br>代码没有破坏原有的功能，或者引入了一些bug。如果单元测试通过的话，把项目编译打包后发布。</p>
<p>这时一个<code>.gitlab-ci.yml</code>文件就可以帮到你了。Gitlab CI，简单来说就是在Gitlab服务器之外，你可以建立一个<code>gitlab-runner</code><br>服务器，这个服务器负责代理一个容器管理工具，比如Docker/Virtual Box等，我们选用的是Docker。commit和tag这样的时间可以<br>触发了CI工作流，假设你push了一个commit到Gitlab服务器上，runner就会探测到需要运行相关的工作流，它建立一个新的Docker容器，<br>从Gitlab上拉取新的代码，然后运行预先定义的scripts，如果没有错误产生，工作流就成功完成了。</p>
<h3 id="定义Gitlab-CI流程"><a href="#定义Gitlab-CI流程" class="headerlink" title="定义Gitlab CI流程"></a>定义Gitlab CI流程</h3><p>假设我们的项目结构是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- foo</span><br><span class="line"> |- src</span><br><span class="line"> |- tests</span><br><span class="line"> |- .gitlab-ci.yml</span><br><span class="line"> |- Pipfile</span><br><span class="line"> |- setup.py</span><br></pre></td></tr></table></figure>

<p><code>.gitlab-ci.yml</code>的一个例子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">local/python:3.8.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change pip's cache directory to be inside the project directory since we can</span></span><br><span class="line"><span class="comment"># only cache local items.</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">PIP_CACHE_DIR:</span> <span class="string">"$CI_PROJECT_DIR/.cache/pip"</span></span><br><span class="line">  <span class="comment"># the local/python:3.8.7 has the correct CA install in system</span></span><br><span class="line">  <span class="attr">REQUESTS_CA_BUNDLE:</span> <span class="string">"/etc/ssl/certs/ca-certificates.crt"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.cache/pip</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">venv/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">upload</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_BRANCH == "master"'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TAG =~ /release\/(.*)/'</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="comment"># activate virtualenv</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">virtualenv</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">virtualenv</span> <span class="string">venv</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span> <span class="string">venv/bin/activate</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># force fetch, update tags</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">fetch.prune</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">fetch.pruneTags</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">fetch</span> <span class="string">--tags</span> <span class="string">-f</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">tag</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># build and install</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python</span> <span class="string">setup.py</span> <span class="string">bdist_wheel</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">dist/*</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dist/*.whl</span></span><br><span class="line"></span><br><span class="line"><span class="attr">upload_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">upload</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">local/python:3.8.7</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TAG =~ /release\/(.*)/'</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">requests</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">packaging</span> <span class="comment"># extract base version</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">simplejson</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">py_ci</span> <span class="string">upload</span></span><br><span class="line"></span><br><span class="line"><span class="attr">release_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">release</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TAG =~ /release\/(.*)/'</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">requests</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">packaging</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">simplejson</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">py_ci</span> <span class="string">release</span></span><br></pre></td></tr></table></figure>


<p>下面是详细解释</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">upload</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">release</span></span><br></pre></td></tr></table></figure>
<p>定义了工作流中的顺序，三个阶段build -&gt; upload -&gt; release</p>
<p>第一个job：初始化环境，安装需要的包</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">build_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_BRANCH == "master"'</span>  <span class="comment"># 当commit被推送到master branch上时这个工作会触发</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TAG =~ /release\/(.*)/'</span>  <span class="comment"># 当commit带有一个'release/'开头的tag时触发</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="comment"># 创建一个虚拟环境，好处是我们可以缓存pip安装的包，下次执行这个工作的时候不需要从头安装这些库</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">virtualenv</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">virtualenv</span> <span class="string">venv</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span> <span class="string">venv/bin/activate</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从gitlab上拉取最新的tag，注意没有这段的话runner只会拉取最新的代码，不会拉取tag</span></span><br><span class="line">    <span class="comment"># 我们需要tag的原因是`versioneer`在git历史中查找tag来生产当前的__version__</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">fetch.prune</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">fetch.pruneTags</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">fetch</span> <span class="string">--tags</span> <span class="string">-f</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">tag</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 编译打包项目</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python</span> <span class="string">setup.py</span> <span class="string">bdist_wheel</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">dist/*</span></span><br><span class="line">  <span class="comment"># artifacts中指定的文件会被工作流中之后的工作继承</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dist/*.whl</span></span><br></pre></td></tr></table></figure>

<p>如果你有一些单元测试，在这一步可以加入一个test阶段</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">upload</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">python</span> <span class="string">setup.py</span> <span class="string">test</span></span><br><span class="line">   <span class="comment"># 如果你用的时pytest的话</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">pytest</span> <span class="string">test/</span></span><br></pre></td></tr></table></figure>

<p>test全部成功的话，test阶段会成功返回，开始下一个upload工作，把打包好的项目wheel文件上传到该Gitlab仓库的Package registry里</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">upload_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">upload</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">local/python:3.8.7</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TAG =~ /release\/(.*)/'</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">requests</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">packaging</span> <span class="comment"># extract base version</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">simplejson</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">py_ci</span> <span class="string">upload</span></span><br></pre></td></tr></table></figure>

<p>我们可以在CI工作中调用Gitlab的API，这也是最简单使用的方法，你可以用任何语言做HTTP请求，我们自己写了一个Python帮助脚本来执行<br>upload，也就是这一步<code>python -m py_ci upload</code>。</p>
<p><code>py_ci</code>的内容很简答，<code>py_ci/upload.py</code>的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">from .helper import PACKAGE_URL, WHEEL_FILE_NAME</span><br><span class="line"></span><br><span class="line">def upload():</span><br><span class="line">    print(&#39;Post target: &#123;&#125;&#39;.format(PACKAGE_URL))</span><br><span class="line">    dist_path &#x3D; &#39;dist&#x2F;&#123;&#125;&#39;.format(WHEEL_FILE_NAME)</span><br><span class="line">    files &#x3D; &#123;&#39;upload_file&#39;: open(dist_path, &#39;rb&#39;)&#125;</span><br><span class="line">    print(&#39;Upload file: &#123;&#125;&#39;.format(dist_path))</span><br><span class="line"></span><br><span class="line">    headers &#x3D; &#123;</span><br><span class="line">        &quot;JOB-TOKEN&quot;: os.environ[&#39;CI_JOB_TOKEN&#39;]  # authenciate with Gitlab API</span><br><span class="line">    &#125;</span><br><span class="line">    res &#x3D; requests.put(PACKAGE_URL,</span><br><span class="line">                       headers&#x3D;headers,</span><br><span class="line">                       files&#x3D;files</span><br><span class="line">                       )</span><br><span class="line">    print(res.content.decode())</span><br><span class="line">    if res.status_code &#x3D;&#x3D; 201:</span><br><span class="line">        print(&#39;Package upload to package registry (generic)!&#39;)</span><br><span class="line">    else:</span><br><span class="line">        raise RuntimeError(res.status_code)</span><br></pre></td></tr></table></figure>
<p>简单来说就是把<code>dist/</code>下的whl文件put到相应的url上，就完成了package的上传。</p>
<blockquote>
<p>Gitalb的API访问需要权限，权限验证有很多种方法，这里的<code>JOB-TOKEN</code>是CI容器中自动定义的环境变量，可以用来验证权限；如果你需要在<br>其他地方调用API，可以在项目的页面生成一个Personal token</p>
</blockquote>
<p>最后一步，建立一个Release</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">release_job:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">release</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">'$CI_COMMIT_TAG =~ /release\/(.*)/'</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">requests</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">packaging</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">simplejson</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">py_ci</span> <span class="string">release</span></span><br></pre></td></tr></table></figure>

<p><code>py_ci/release.py</code>的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import simplejson</span><br><span class="line"></span><br><span class="line">from .helper import PACKAGE_URL, TAG_NAME, WHEEL_FILE_NAME, CI_API_V4_URL, CI_PROJECT_ID, FULL_VERSION</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def release():</span><br><span class="line">    post_target &#x3D; CI_API_V4_URL + f&quot;&#x2F;projects&#x2F;&#123;CI_PROJECT_ID&#125;&#x2F;releases&quot;</span><br><span class="line">    headers &#x3D; &#123;</span><br><span class="line">        &#39;JOB-TOKEN&#39;: os.environ[&#39;CI_JOB_TOKEN&#39;],</span><br><span class="line">        &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    payload &#x3D; simplejson.dumps(release_data())</span><br><span class="line">    res &#x3D; requests.post(post_target,</span><br><span class="line">                        data&#x3D;payload,</span><br><span class="line">                        headers&#x3D;headers</span><br><span class="line">                        )</span><br><span class="line">    print(&#39;Response code: &#123;&#125;&#39;.format(res.status_code))</span><br><span class="line">    print(res.content.decode())</span><br><span class="line">    if res.status_code &#x3D;&#x3D; 201:</span><br><span class="line">        print(&#39;Release succesful! Receipt:&#39;)</span><br><span class="line">        print(res.content)</span><br><span class="line">    else:</span><br><span class="line">        raise ValueError(res.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def release_data():</span><br><span class="line">    data &#x3D; &#123;</span><br><span class="line">        &quot;name&quot;: f&quot;Release &#123;FULL_VERSION&#125;&quot;,</span><br><span class="line">        &quot;tag_name&quot;: TAG_NAME,</span><br><span class="line">        &quot;description&quot;: f&quot;Version &#123;FULL_VERSION&#125;&quot;,</span><br><span class="line">        # &quot;milestones&quot;: &quot;&quot; # if specified must exist</span><br><span class="line">        &quot;assets&quot;: &#123;</span><br><span class="line">            &quot;links&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;name&quot;: WHEEL_FILE_NAME,</span><br><span class="line">                    &quot;url&quot;: PACKAGE_URL</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return data</span><br></pre></td></tr></table></figure>
<p>我们按照Gitlab API的要求，在<code>release_data</code>函数中提供了必要的release信息，最重要的是<code>assets&quot;字段：</code>assets`字段是选填的，如果你不提供的话，产生的release只会包含一份repo内源码的打包，那我们怎么让release中也包含上一步<br>upload里上传的whl文件呢？只需要提供一个URL连接到package registry里的对应whl文件的地址就可以</p>
<h3 id="私有CA证书"><a href="#私有CA证书" class="headerlink" title="私有CA证书"></a>私有CA证书</h3><p>在部署Runner的时候，遇到了一个比较棘手的问题：我们的Gitlab实例只能在内网里可见，因此无法取得一个公开的SSL证书，我们只得<br>使用一张自签发证书来加密Gitlab服务器，但是CI里的Docker容器环境里没有这张私有证书，会导致无法和Gitlab服务器通讯。</p>
<p>Gitlab官方给出了<a href="https://docs.gitlab.com/runner/configuration/tls-self-signed.html" target="_blank" rel="noopener">解决方法</a>，简单来说就是指定一个<br><code>tls-ca-file</code>配置给Docker容器，然后Docker容器会从该文件读取CA证书，遗憾的是这个方法经测试不能奏效。</p>
<p>我们在<code>python:3.8.7-alpine</code>官方镜像上，叠加了一层，把自签名的CA证书打包到镜像中，因此你可以看到<code>.gitlab-ci.yml</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image: local&#x2F;python:3.8.7</span><br></pre></td></tr></table></figure>
<p>用的是这张本地镜像，<code>local/python:3.8.7</code>和普通的python镜像在功能上没有任何区别</p>
<blockquote>
<p>如果你的Gitlab服务器用的是经过认证的公有证书，那你完全可以使用其他任何的Docker镜像，<code>local/python:3.8.7</code>只是为了解决<br>SSL认证的无奈之举</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Gitlab</tag>
        <tag>Continuous Integration</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo框架+NexT主题建设个人博客</title>
    <url>/article/hexo-blog/</url>
    <content><![CDATA[<h2 id="Hexo博客框架"><a href="#Hexo博客框架" class="headerlink" title="Hexo博客框架"></a>Hexo博客框架</h2><p>Hexo 是一个静态网页博客框架，简约而不简单，<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Github repo</a> 上已经有有30k星星。</p>
<a id="more"></a>

<p>什么是静态博客？通过数据库查询、调用、展示的叫做“动态”，直接生成纯 <code>.html</code> 网页文件的叫做“静态”。<code>Hexo</code>支持markdown格式文章，拥有者在本地编辑了 <code>.md</code> 格式的博文后，调用 <code>Hexo</code> 的本地库生成绚丽的静态网页后，部署到托管系统上，就可以通过其他域名访问了。</p>
<p>Flask  和 Django 这样的动态web框架，用来写博客这样业务逻辑十分简单的应用就有点牛刀杀鸡了。相对来说，静态博客的显然的好处就是轻量化和性价比：使用 Hexo，不用脚本语言编写复杂的服务器段逻辑；不用从数据库中拉取博文和渲染网页；不用租用服务器和数据，只需要一个免费的文件托管系统，如 Github Pages，就可以上线了。如果不满足于 Github Pages 的免费服务，可以用很少的花费租用一个域名，链接 Github Pages 的网页。</p>
<h3 id="Hexo的特性"><a href="#Hexo的特性" class="headerlink" title="Hexo的特性"></a>Hexo的特性</h3><ul>
<li><p>完美支持Markdown</p>
</li>
<li><p>完美支持emoji👍</p>
<ul>
<li>如果你使用的是苹果设备，写文章时可以直接在vscode里输入emoji</li>
</ul>
</li>
<li><p>支持代码高亮</p>
<ul>
<li>Python</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> n=<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> factorial(n<span class="number">-1</span>)*n</span><br></pre></td></tr></table></figure>
</li>
<li><p>一键部署到Github Page上</p>
</li>
</ul>
<h2 id="NexT主题"><a href="#NexT主题" class="headerlink" title="NexT主题"></a>NexT主题</h2><p><code>NexT</code> 是 <code>Hexo</code> 支持的众多第三方主题中的一个。当然，你不一定要用NexT这个主题，还有其他很多的主题供你选择。NexT主题订制的博客简约干净，而且有全面的用户自定义设置，你可以选择你需要哪些功能和模块，丰俭由人。</p>
<p>我使用的是单栏目的Mist主题，清爽干净，浏览文章的时候侧边栏显示Table of Contents，而且会随着文章向下划动，高亮当前区域在TOC中的位置。</p>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ol>
<li>Hexo是一个 <code>Node.js</code> 实现的库，所以确保你拥有<ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener"><code>Node.js</code></a> - macOS 提供打包好的installer</li>
<li><code>git</code> - macOS 随机预装🎉，你也可用 <code>homebrew</code> 安装</li>
</ul>
</li>
<li>使用 <code>Node.js</code> 的 package manager <code>npm</code><br><code>npm install hexo</code></li>
</ol>
<h3 id="创建一个博客项目"><a href="#创建一个博客项目" class="headerlink" title="创建一个博客项目"></a>创建一个博客项目</h3><p>成功安装 <code>Hexo</code> 后，如果你想要把博客项目放置在<code>&lt;folder&gt;</code>里，运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>然后会得到一个结构如下的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">    └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_config.yml</code> - 控制站点的设置<ul>
<li>如何<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a></li>
</ul>
</li>
<li><code>package.json</code> - 应用程序的信息</li>
<li><code>scaffolds</code> - 模板文件夹<ul>
<li>当我们新建文章时，Hexo 会使用模版</li>
</ul>
</li>
<li><code>source</code> - 资源文件夹<ul>
<li>存放用户文章的源文件，和其他媒体资源</li>
<li>除 <code>_posts</code> 目录外，其他以 <code>_</code> 开头的文件/文件夹都会被忽略</li>
<li>Markdown 和 HTML 文件会被解析放进 <code>public</code> 文件夹，其他的文件会被拷贝过去</li>
</ul>
</li>
<li><code>themes</code> - 主题文件夹</li>
</ul>
<h3 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a>安装 NexT 主题</h3><p>安装 <code>Hexo</code> 的主题非常简单，只需要将主题文件拷贝到站点目录的 <code>themes</code> 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line"><span class="comment"># 克隆最新版本</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>然后启用主题。编辑 <code>&lt;folder&gt;/_config.yml</code>，找到 <code>theme</code> 字段，更改为</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span> <span class="comment"># 替换默认的landscape主题</span></span><br></pre></td></tr></table></figure>

<p>NexT也有一个独立的配置文件，同站点的配置文件一样，也叫 <code>_config.yml</code>。为了描述方便，将前者称为</p>
<ul>
<li>站点配置文件：<code>&lt;folder&gt;/_config.yml</code></li>
<li>主题配置文件：<code>&lt;folder&gt;/themes/next/_config.yml</code></li>
</ul>
<p>我们主要通过这两个文件控制<code>Hexo</code>, <code>NexT</code>主题和其他插件的行为。</p>
<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>NexT 提供了四个子主题 (Scheme) 供选择</p>
<ul>
<li>Muse - NexT的最初版本，黑白主题，大量留白</li>
<li>Mist - Muse紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
<li>Gemini</li>
</ul>
<p>在主题配置文件，更改 Scheme 字段</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span> <span class="comment">#/Muse/Pisces/Gemini</span></span><br></pre></td></tr></table></figure>

<p>设置网站的基本信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="comment"># 网站名称</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="comment"># 网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="comment"># 网站介绍</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="comment"># 关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="comment"># 网站作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span> <span class="comment"># 设置语言为简体中文</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="comment"># 时区</span></span><br></pre></td></tr></table></figure>

<p>目前我们只需要设置这些字段，参考<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">Hexo站点配置</a>。</p>
<h3 id="打开浏览器试试"><a href="#打开浏览器试试" class="headerlink" title="打开浏览器试试"></a>打开浏览器试试</h3><p>Hexo 的任何新建项目包含一个默认文章，如果进入目录 <code>&lt;folder&gt;/source/_posts/</code>，有一篇叫做 <code>hello-world.md</code> 的文章。所以，即使还不知道如何在Hexo框架下写文章，我们也可以先把网站运行起来，看看效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产静态文件</span></span><br><span class="line">npx hexo generate</span><br><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">npx hexo server</span><br></pre></td></tr></table></figure>

<p>如果Hexo成功编译了静态网页文件，我们会看到Hexo提示网址为：<code>http://localhost:4000/</code>。浏览器打开这个网址，博客成功在本地运行⬇️。如果你没有编辑博文的话，看到的应该是默认的Hello World文章。</p>
<p><img src="/article/hexo-blog/blog_snapshoot.png" alt=""></p>
<h2 id="编写博客"><a href="#编写博客" class="headerlink" title="编写博客"></a>编写博客</h2><p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new &lt;layout&gt; title</span><br></pre></td></tr></table></figure>

<p>Hexo会在<code>source/_posts/</code>下创建一个<code>title.md</code>文件。可选的layout有三种，默认post</p>
<ul>
<li>post - 文章</li>
<li>page - 页面 （如索引，自我介绍）</li>
<li>draft - 草稿</li>
</ul>
<p>编辑<code>title.md</code>。Hexo会插入一个<code>front-matter</code>设置段落，控制这篇文章的meta-data。这个段落可以是yaml格式的，用triple dash结束；也可以是json，用三个分号结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: #文章题目</span><br><span class="line">toc:</span><br><span class="line">  number: #是否编号</span><br><span class="line">  enable: #是否显示TOC</span><br><span class="line">date: 2020-05-02 18:30:55</span><br><span class="line">tags: # 标签</span><br><span class="line">categories: # 分类</span><br><span class="line">permalink: # 文章的永久链接</span><br><span class="line">comments:</span><br></pre></td></tr></table></figure>

<p>在<code>front-matter</code>的<code>---</code>以下编辑文章，可以使用Markdown支持的排版，包括emoji，可以插入本地照片或图床上的照片，本地照片会被Hexo打包在<code>public</code>目录中一同上传至托管系统。</p>
<h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><p>写好文章后，下一部就是把博客真正地部署在互联网上，让所有人都能看到。</p>
<p>先更新文章的HTML网页，生产文件放在<code>public</code>目录中</p>
<p><code>hexo generate</code></p>
<p>如果想要使用Gitub Pages部署博客。先在 Github上建立一个<code>&lt;example&gt;.github.io</code>的仓库，把<code>&lt;example&gt;</code>替换为你的Github id。</p>
<p>部署到Pages上有两种方法</p>
<ol>
<li>在本地部署</li>
</ol>
<p>安装<code>hexo-deployer-git</code>插件，在站点目录中运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>编辑站点配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">'git'</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;example&gt;/&lt;example&gt;.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>把<code>&lt;example&gt;</code>替换成你的Github id。</p>
<blockquote>
<p>‼️注意，<code>branch</code>字段必须为master。Github Pages的server只能读取master分支上的文件。</p>
</blockquote>
<p>运行，Hexo将<code>public</code>目录push到master分支上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>最后一步，在Github仓库的Settings中找到Github Pages，启用选择master分支。打开浏览器输入<code>&lt;example&gt;.github.io</code>，如果可以看到博客，说明站点部署成功。</p>
<p>之后每次更新博文，运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean <span class="comment"># 删除public文件夹和数据库</span></span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>或者节约时间，Hexo支持缩写命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d -g <span class="comment"># 生成并部署</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Travis部署<br><code>Travis</code>是一个代码部署平台，可以与GitHub联动，监测github上某个仓库的某些分支，有commit后，寻找分支中的配置文件<code>.travis.yaml</code>，自动创建环境，允许指令部署。Travis有专门的Pages的部署选项，几个简单的配置之后就可以实现创作👉Push到仓库👉搞定。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GH_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">commiter_from_gh:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">target_branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">hexo</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>
<p>假设你的源代码存放在hexo分支，网站代码存放在master分支。需要生成一个有repo权限的token，设置在travis项目的环境变量里，叫<code>$GH_TOKEN</code>，让travis有权限写入master分支。</p>
<h2 id="关联域名"><a href="#关联域名" class="headerlink" title="关联域名"></a>关联域名</h2><p>如果不喜欢<code>&lt;example&gt;.github.io</code>这样的二级域名，可以自己租用域名，然后链接到Github Page上。</p>
<p>租用域名的平台很多，一个选择是<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">阿里云</a>。</p>
<p>假设租用<code>mydomain.com</code>，审核完成，到控制台/域名，找到刚刚购买的域名，配置解析，添加一条记录</p>
<ul>
<li>记录类型选择CNAME，解析到网址（而不是IP）</li>
<li>主机记录<ul>
<li>输入@，就是直接解析主域名<code>mydomain.com</code></li>
<li>输入www，解析<code>www.mydomain.com</code></li>
<li>输入blog，解析<code>blog.mydomain.com</code></li>
</ul>
</li>
<li>记录值输入<code>&lt;exmaple&gt;.github.io</code>，<code>example</code>替换成你的Github ID</li>
</ul>
<p>创建<code>source/CNAME</code>，内容<code>mydomain.com</code>，然后deploy</p>
<p>你也可以直接在Github仓库的设置，填写Custom domain，Github会帮你添加CNAME在master分支的根目录下。</p>
<blockquote>
<p> 可能需要等待一会，让DNS服务器更新</p>
</blockquote>
<p>访问<code>mydomain.com</code>，可以看到博客。访问<code>&lt;example&gt;.github.io</code>，会被重定向至<code>mydomain.com</code>。</p>
<p>这样，一个虽然有些简陋，但是五脏俱全的博客站点就建设完成了。</p>
<p>下一篇博客，笔者会讲讲如何优化Hexo博客，</p>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://hexo.io/docs/setup" target="_blank" rel="noopener">Hexo 文档</a><br><a href="https://theme-NexT.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT 文档</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>游记之夏日刺桐</title>
    <url>/article/quanzhou-trip/</url>
    <content><![CDATA[<p>四月去了趟惠州，没几天因为锘潼有急事就送她回去了。一晃眼已经五月中旬了，终于定下来去福建玩一趟。</p>
<a id="more"></a>

<p>原定的计划是<strong>厦门+泉州</strong>。没想到天意弄人，动车到厦门后，得知要备案厦门当地的健康码。可能是因为我的身份证号是42（湖北区号）开头，即使我不是湖北籍，好几年都没到过湖北，厦门的健康码却是红的。跟厦门站的工作人员沟通备案了后，才得以出站，但是酒店都守死规矩不接待红码客人。吃了两个闭门羹，订单都退了后，将近半夜终于找到一个愿意接待的酒店住下来。</p>
<p>这样一番折腾下来，本来对厦门的期待就已耗去大半。想到厦门的景区很大概率也是只看厦门本地的健康码，都懒得去碰碰运气了。第二天上午就直奔泉州去了。</p>
<h2 id="富有生活情趣的泉州"><a href="#富有生活情趣的泉州" class="headerlink" title="富有生活情趣的泉州"></a>富有生活情趣的泉州</h2><p>订了一个泉州的老牌五星级酒店，泉州酒店。这种以某个地的地名命名的酒店，一般都是年代比较久的。泉州酒店1990年建成，虽然背着五颗星，却是上个世纪的五颗星。设施处处显示着上了点年纪的豪华感。厚厚的地毯，走廊墙上的迎客松油画，古色古香的木质电梯饰板，还有砖红色的外墙。五星级酒店价格却平平，可能是很多人欣赏不来这种古典的质感吧。好处是，位置在老城区的中心，被主要的景点包围，步行美食街西街更是只要几分钟。</p>
<p>入住了酒店，长舒了一口气，看来极不负责的健康码只是厦门一市的特例。泉州的酒店查看了中国移动的行程查询系统，景点用的是福建省的八闽码。</p>
<p>好事不成双，因为疫情尚未结束的原因，泉州一部分景区还没有开放，包括市区内的知名寺庙，供奉妈祖信仰的天后宫，清真寺清净古寺、开元寺和东西塔，以及承天寺都大门紧闭。第一天吃了好几个闭门羹，倒是路上吃喝不断。</p>
<ul>
<li>玖肆幺七 - 茶餐厅</li>
<li>秉正堂 - 天后宫隔壁的糖水店</li>
<li>壶见 - 闽南茶饮连锁</li>
<li>邻家闽菜馆 - 土笋冻很有特色</li>
</ul>
<p>福建菜系独树一帜，以可口革囊星虫为原料的<a href="https://zh.wikipedia.org/wiki/%E5%9C%9F%E7%AC%8B%E5%86%BB" target="_blank" rel="noopener">土笋冻</a>最为出名。很多人都有所耳闻这种像虫子馅的果冻的黑暗料理。其实味道比较淡，有淡淡的海腥味，在夏天蘸着蘸水吃很清凉。虽然与广东相邻，但闽菜与粤菜迥然不同，反而与台湾菜更加相近。</p>
<p>泉州车牌号闽C，排在厦门前面，但扎扎实实是个发展缓慢的老城。城区里老房子居多，四处穿行的电动车成了狭窄街道里的血液。午后，在街道上闲逛，行道树一直延伸到道路上空，在路上打了一把严严实实的伞。两边的商店都是貌不惊人的样子，安安静静等着顾客上门，并不以华丽的门面招徕顾客。不时穿插一个小学，或是一个中学，闹市中取一片读书的天地。</p>
<p>吃过晚餐后，锘潼说要去西街买糯米蛋糕。穿过酒店后细细长长的小巷子，路灯很暗，人家大多都已熄灯入睡，只有几家小食店只留下卷帘门上的小门，向里一瞥，黑暗中只有一方小小的电视屏幕，映出未眠人不太真实的轮廓。从小巷子一穿出，就扎入了灯火辉煌的西街。西街的尽头是乳白色的钟楼，很可爱的造型，越过钟楼就是东街了。钟楼很不幸处在两条道路交汇的十字路口正中央，四个方向各被安上一排红绿灯，成了车流漩涡中孤单的灯塔。</p>
<h2 id="偷得半日闲"><a href="#偷得半日闲" class="headerlink" title="偷得半日闲"></a>偷得半日闲</h2><p><strong>洛阳桥</strong>，又名<strong>万安桥</strong>，名为洛阳却不在洛阳，有中国古代四大名桥之誉。如果看过最近在播的正午阳光剧《清平乐》，里面有个北宋大臣蔡襄蔡君谟，洛阳桥就是他主持建造的。桥北侧是惠安，南侧是泉州，横亘在洛阳江上，所以是中国第一座跨海石桥。</p>
<p>很多人称赞洛阳桥形态优美，主要是因为它的<strong>筏型桥墩</strong>。从侧面看过去，好像无数只小船一字排开，架起长桥。</p>
<p><img src="luoyang-bridge1.jpeg" alt=""></p>
<blockquote>
<p>这样的设计使得洛阳桥可以经受上游江流和下游海潮的交互冲击</p>
</blockquote>
<p>更有特色的是，仔细看桥墩上贴满了海蛎。在修造过程中海蛎作为加固桥墩的手段，自建成之日，就频频遭贼人之手，后来历代皆有盗挖洛阳桥海蛎者判处监禁的律例。</p>
<p>走到桥心，有一座白塔，叫“月光菩萨塔”，方形底座上刻着几句佛语。初看就觉得字体十分近代，不似前朝刚修建时刻上去的，反倒有几分文革字的样子。的确，1946年国共内战，国军将桥面完全炸毁，桥面上文物尽毁，现存的文物是中国人民共和国政府组织修复的。</p>
<p><strong>清源山</strong>，离泉州市中心不远，却是一尘不染、清净幽深。清源山有名在三教共存，佛教、道教和伊斯兰教在这里皆有古迹。</p>
<h3 id="道教"><a href="#道教" class="headerlink" title="道教"></a>道教</h3><p>山门处的老君岩，是老子的石像。老子席地而坐，左手扶膝，右手凭几，形态塑造得安然沉静，又飘逸洒脱。前面一块碑，上书“老子天下第一”，霸气逼人。</p>
<h3 id="佛教"><a href="#佛教" class="headerlink" title="佛教"></a>佛教</h3><p>路过老君岩后，山路石阶蜿蜒而上，爬得人颇有些上气不接下气。好在山中绿树成荫，凉风阵阵，不至于走得满头大汗。路旁时不时冒出宣传栏，一个卡通版的老君岩，在说“老君喊你来运动”，让你不好意思打退堂鼓。</p>
<p>一直走到半山腰，是弘一法师的舍利塔。弘一法师生前擅诗词书法，高僧之外，也是位大艺术家。舍利塔旁山石上，刻了弘一法师临终最后的墨迹，“悲欣交集”，是他一生的总结。敬仰一番弘一法师的大智慧后，这四字让人喟叹。</p>
<h3 id="伊斯兰教"><a href="#伊斯兰教" class="headerlink" title="伊斯兰教"></a>伊斯兰教</h3><p>清源山鲜为人知的是与伊斯兰教也有关联。灵山圣墓不在主景区内，游客很少踏足。唐武德年间，穆罕默德门徒三贤、四贤来泉州传教，殁葬于灵山，称伊斯兰圣墓。</p>
<p>爬山不是件轻松事，好在移步换景，走走停停。浮生若梦，能偷出半日闲，来清源山走走，吸几口山间的清凉空气，览一番僧人墨客的古迹，不亦乐乎。</p>
<h3 id="佛跳墙"><a href="#佛跳墙" class="headerlink" title="佛跳墙"></a>佛跳墙</h3><p>闽菜最有名的，佛跳墙当仁不让。中午烈日当空，找个有空调的地方吃午饭。“宋小谨”一店，大众点评说佛跳墙味道很好。要了一份单人的佛跳墙，价格已不平，68元。</p>
<p>佛跳墙使一瓷盅乘着，里面有海参、暴雨、花胶，冬菇等等大补的食材，辅以浓稠高汤煨上几个小时，味道鲜美。古人云</p>
<blockquote>
<p>坛启荤香飘四邻，佛闻弃禅跳墙来</p>
</blockquote>
<p>意思连佛闻到此菜的香气，都忍不住从寺庙中跳出来想要吃口荤的。</p>
<p>泉州丝绸之路通商的全盛时期，曾是一段时间世界上最大的都市。泉州博物馆记载，北宋年间泉州的人口已有上百万口。2017年统计，泉州市区人口也不过一百五十二万人。泉州又称鲤城，古称刺桐、温陵。现在的行政区划，鲤城区是泉州的一个区，酒店附近一条路叫温陵路。泉州随处可见这样古风十足的地名。</p>
<h2 id="食菜事魔"><a href="#食菜事魔" class="headerlink" title="食菜事魔"></a>食菜事魔</h2><p>不知读者们是否看过金庸先生的《倚天屠龙记》，主角张无忌，误打误撞成了明教教主。这个被江湖其他门派成为魔教的明教，现实的原型其实是<strong>摩尼教</strong>。书中也提到魔教又称摩教，其实就是摩尼教。</p>
<p>摩尼教是世界唯一一个完全毁灭的世界性宗教，唯一尚存的是中国本土化的摩尼教“明教”。而明教历经各个朝代，所剩的唯一一个寺庙就是泉州南郊的草庵寺。</p>
<p>草庵寺离泉州城区半小时的车程，坐落在半山上，供奉有世界上唯一的摩尼光佛坐像，也是世界现存唯一摩尼教寺庙遗址。国家重点文物保护单位，海上丝绸之路的遗产。</p>
<p>走到门口，轻轻推开铁门，发现门并没有锁上，问寺庙里的僧侣，说疫情的原因还没有开放，不过可以随便看看。</p>
<p>在正殿拜了拜，注意到供奉的是弥勒佛，这是个很有意思的现象，为什么佛教的弥勒佛会出现在明教寺庙中呢？摩尼教由波斯人摩尼创立，是一个吸取了佛教、犹太教和基督教等等很多宗教的教义的产物。摩尼教在唐朝的时候传入中国，一说是武后当时苦于中国传统宗教无一有容纳女人称帝的，而摩尼教的教义框架中，女性的地位甚高，正好可以解释武后称帝的正统性，于是武后优待摩尼教，一直到玄宗认定其“妄称佛教”驱逐胡僧。摩尼教为了减少在中国的传教阻力，使用佛经术语翻译经文，所以有了很多神似佛教的概念。</p>
<p>《倚天屠龙记》中，各大门派忌惮明教，称其“食菜事魔”，意思是吃素，侍奉魔鬼。然而明教确实是吃素，可侍奉魔鬼一说却是其他门派的空穴来风。草庵寺后山上有明教的几句箴言</p>
<p><img src="caoan-stone.jpeg" alt=""></p>
<blockquote>
<p>清净光明，大力智慧，无上至真，摩尼光佛。</p>
</blockquote>
<p>决战光明顶一站，明教众人知大数已尽，一齐诵读</p>
<blockquote>
<p>焚我残躯，熊熊圣火。生亦何欢，死亦何苦？<strong>为善除恶，惟光明故</strong>。喜乐悲愁，皆归尘土。怜我世人，忧患实多！怜我世人，忧患实多！</p>
</blockquote>
<p>“清净光明”，和“惟光明故”，恰恰说明了明教/摩尼教不仅侍奉的不是魔鬼，而且把黑暗看作的自己的对立面。与佛教、基督教不同，摩尼教持非常简单的二元论，认为世界分为物质的黑暗世界和精神的光明世界，否定物质世界，希望通过虔诚信仰回归光明世界。</p>
<h2 id="圆宝台湾小吃"><a href="#圆宝台湾小吃" class="headerlink" title="圆宝台湾小吃"></a>圆宝台湾小吃</h2><p>隐藏在泉州深巷里的台湾小吃店，现在只提供外卖，没有堂食。我点了最爱卤肉饭，还有鸭头、米血糕。卤肉浇头非常地道，有那份古早味，让人不禁回忆起在港大念书时附近叫阿远来了的台湾小吃店的口味。卤肉肉汁渗入粒粒分明的白米饭中，狼吞虎咽吃了一大碗。米血糕在菜单上标价一元一个，以为是一元手指甲盖那么大的一块，没想到买了四元的，满满堆了一盘，原来是一元一大块，再切成手指甲盖那么大。</p>
<p>价格很平，两个人买了一大袋子带回酒店吃，只五十八元。</p>
<h2 id="寻蚵壳厝"><a href="#寻蚵壳厝" class="headerlink" title="寻蚵壳厝"></a>寻蚵壳厝</h2><p>蚵壳厝，指的是用牡蛎壳建筑的房子。最初为福建人靠海用海，缺少砖石建屋，只好用牡蛎壳浇筑房屋的不得已之举。听闻现在泉州的蟳埔村，还留有几栋这样的房屋。蟳埔村是一个蜗居在泉州市区的城中渔村，里面握手楼鳞次栉比，道路狭窄仅容一车通过。把车停在村边，下车步行寻找这迷宫中是否还有蚵壳厝。</p>
<p>寻寻觅觅，只找到一间屋的外墙，窗户周围一圈是牡蛎壳砌的，美观作用大于实用。不过家家户户门前都有几筐牡蛎，无处不弥漫一股海腥味。显得破败的村子里，只有头上扎着当地的鲜花头饰的老奶奶们，坐在马扎上开牡蛎。最初道听途说，以为这是个很有特色的村子，没想到蚵壳厝最终还是败给了现代的砖瓦房，蟳埔村与今天深圳的随便一个城中村并无二致。</p>
<p>于是下午将将三点，地面被晒得滚烫的时候，放弃了寻找蚵壳厝，竟一下子不知道怎么打发时间为好。大众点评上刷来刷去，想到不如去洗脚健足。洗脚这个项目，是我和锘潼出门的传统保留项目了。选了一家叫大自然会所的，虽然名字很土，评价却甚好。</p>
<p>泡脚，按头，捏脚，开背，此处略去不提。</p>
<p>洗完脚，一身畅快之后。在旁边的万达广场吃锘潼心心念念好几天的韩国烤肉。店名叫<strong>韩悦</strong>，分量很足，肉蛮新鲜。三小碟酱料，分别是孜然，酱肉，和一个酸爽的酱，蘸烤肉很讲究。两个人烤了六盘肉，吃得快要走不动了。锘潼说无论怎样都要散散步消消食，于是开到江北公园，一个僻静处。没有路人，没有路灯，只有一江水，倒映着远处城市的灯火，和石桥黑黝黝的轮廓。在几乎无光的环境，人眼都看不清楚，用iPhone 11拍了这张相片</p>
<p><img src="night-bridge.jpeg" alt=""></p>
<p>iPhone用了长曝光，大概三秒左右，合成出这样一张亮如黄昏的照片。说真的，我用肉眼都看不到桥上的白色扶手。</p>
<p>坐在石阶上吹了一阵子凉凉的晚饭，心满意足。</p>
<h2 id="六鳌画廊"><a href="#六鳌画廊" class="headerlink" title="六鳌画廊"></a>六鳌画廊</h2><p>福州在福建省是一个地位很尴尬的城市，论经济和大学，不如厦门，论旅游资源，又远不如泉州，甚至漳州，因为爸爸去哪儿在南靖土楼的那期节目，都被带起了名气。上次来过漳州看土楼，所以这次在漳州-厦门-泉州地图的周边，选了六鳌这样一个地方。</p>
<p>六鳌是一个半岛上不大的村镇，在福建省伸进台湾海峡的海岸线上。像这样的地方能被人知道，成为“网红”，进而在五一十一这样的黄金假期里被游客挤得人山人海，大多需要三个条件</p>
<ul>
<li>有一些“比较酷”的玩点，不能太老土，不能是城市里随处可见的娱乐比如说公园购物中心这类的</li>
<li>紧邻一二线城市</li>
<li>但又不能太近，开车一两个小时最好</li>
</ul>
<p>这样以来，城市人口在节假日避开人流太大，当天晚饭的景点，往往会向城市周边的这样的卫星城分散开来。惠州的巽寮湾，就是托地理位置上离深圳广州有一个微妙的距离，成了都市人的后花园。若说巽寮湾、六鳌这样风景的半岛，在中国长长的海岸线上要多少有多少，哪些能成目的地，还是要看消费力在哪。</p>
<p>六鳌的唯一一个旅游资源时抽象画廊。此画廊非真画廊，而是海边的形状奇异的石头。有的像猪，有的像老虎，像什么全凭自己想象力，所以叫做抽象画廊。景区并不大， 还没开发好，门票却不便宜，全票六十元一人。租了辆双人单车，在海岸线风车下骑了一圈，倒是比看石头惬意。</p>
<p>休渔期中，镇上的海鲜十分昂贵，皮皮虾九十一盘。晚餐索性自己解决了，开车到半小时外的县城里，找了个大超市，买了海底捞自热火锅。到家等天黑地面凉下来，在民宿后面的沙地上，有一伞桌，喝酒吃火锅，给闽南之行画上个悠闲的句号。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><blockquote>
<p> 家住江南，又过了、清明寒食。花径里、一番风雨，一番狼藉。红粉暗随流水去，园林渐觉清阴密。算年年、落尽刺桐花，寒无力。</p>
<p>庭院静，空相忆。无说处，闲愁极。怕流莺乳燕，得知消息。尺素始今何处也，彩云依旧无踪迹。谩叫人、羞去上层楼，平芜碧。</p>
<p>《满江红·暮春》辛弃疾</p>
</blockquote>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>泉州</tag>
        <tag>福建</tag>
      </tags>
  </entry>
</search>
